<?php
/**
 * LocationsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Nedap Livestock Connect
 *
 * # Access Tokens With each endpoint information can be retrieved for one
 * installation only. The access token controls which installation will be
 * accessed. This means that you need to use different access tokens for
 * different installations.      # Scopes For each installation, different
 * packages of data ('Connections') are available. On
 * connect.nedap-livestockmanagement.com/nedap-livestock-connect/ an overview
 * of the different available packages and the corresponding enpdoints is
 * given. The basic connection is free to use, but for some of the other
 * connections additional charges will be applied. In order to get access to
 * other connections your application needs permission from us, and from the
 * specific farmer. The first part can be arranged by contacting Nedap, the second part by OAuth2 scopes.  In OAuth2, scopes let you specify which data your application needs from a user. When requesting permission from a farmer to access his data, you specify which scopes you need, what kind of data you want. If the farmer accepts, you will receive a token for those specified scopes. With that token, you can only access API Endpoints that are allowed by those scopes, since every endpoint needs a specific scope to access it.  Summarized:    - Endpoints are protected by scopes. To access them, you need a token with the correct scopes.    - When requesting access to a farm, by default you get access to the scope 'account', which gives access to basic data. If you need more, send those scopes along with the request.    - You can only request scopes that are permitted by your application. If you need more, contact us.  To access the different available connections, use the following scopes:  ## Cows  ### Basic Connection - account: Access to basic data: animals, groups, and calendar events  ### Attentions Connection - account: Access to attentions  ### Heat Detection Advanced Connection - heat_detection: Access to heat detection  ### Health and Management Advanced Connection - behaviour: Access to behavioural data: activity, eating, standing, lying, standups and walking - rumination: Access to rumination data - inactive: Access to inactive data  ### Sire Advice Connection - sire_advice: Access to sire advices  ## Pigs  ### Basic Connection - account: Access to basic data: animals, groups, calendar events and attentions  ### Sow Weights Connection - weights: Access to weighing data  ### Sorting Connection - sorting: Access to sorting data  ### Pig Performance Testing Connection - pig_performance_testing: Access to pig performance testing data  ### Feeding Connection - feeding_animal_summaries: Access to feeding animal summaries - feeding_location_summaries: Access to feeding location summaries - feeding_extended_location_summaries: Access to feeding location summaries including station totals  # Standards  In the API we use the following standards:  - Timestamps are always in UTC in ISO 8601. An example would be '2017-10-23T20:21:01Z'. - Weights are always in grams.  # HTTP Error codes  We use the following HTTP codes to signify errors: - 400 (Invalid data): The data that is sent is invalid (for example an incorrect Animal object). The return body contains pointers on the specific errors. - 401 (Unauthorized): The provided token is not valid or has expired. - 403 (Forbidden): The provided token is valid but has no access to the accessed endpoint. - 404 (Not found): The object that is requested is not found. - 500 (Server error): Something unexpected went wrong on the server.
 *
 * OpenAPI spec version: v1
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.15
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * LocationsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LocationsApi {

  /**
   * @var ClientInterface
   */
  protected $client;

  /**
   * @var Configuration
   */
  protected $config;

  /**
   * @var HeaderSelector
   */
  protected $headerSelector;

  /**
   * @param ClientInterface $client
   * @param Configuration $config
   * @param HeaderSelector $selector
   */
  public function __construct(
    ClientInterface $client = NULL,
    Configuration $config = NULL,
    HeaderSelector $selector = NULL
  ) {
    $this->client = $client ?: new Client();
    $this->config = $config ?: new Configuration();
    $this->headerSelector = $selector ?: new HeaderSelector();
  }

  /**
   * @return Configuration
   */
  public function getConfig() {
    return $this->config;
  }

  /**
   * Operation locationById
   *
   * Return a Location.
   *
   * @param int $id The location id (required)
   *
   * @return \Swagger\Client\Model\Location
   * @throws \InvalidArgumentException
   * @throws \Swagger\Client\ApiException on non-2xx response
   */
  public function locationById($id) {
    [$response] = $this->locationByIdWithHttpInfo($id);
    return $response;
  }

  /**
   * Operation locationByIdWithHttpInfo
   *
   * Return a Location.
   *
   * @param int $id The location id (required)
   *
   * @return array of \Swagger\Client\Model\Location, HTTP status code, HTTP
   *   response headers (array of strings)
   * @throws \InvalidArgumentException
   * @throws \Swagger\Client\ApiException on non-2xx response
   */
  public function locationByIdWithHttpInfo($id) {
    $returnType = '\Swagger\Client\Model\Location';
    $request = $this->locationByIdRequest($id);

    try {
      $options = $this->createHttpClientOption();
      try {
        $response = $this->client->send($request, $options);
      } catch (RequestException $e) {
        throw new ApiException(
          "[{$e->getCode()}] {$e->getMessage()}",
          $e->getCode(),
          $e->getResponse() ? $e->getResponse()->getHeaders() : NULL,
          $e->getResponse() ? $e->getResponse()->getBody()->getContents() : NULL
        );
      }

      $statusCode = $response->getStatusCode();

      if ($statusCode < 200 || $statusCode > 299) {
        throw new ApiException(
          sprintf(
            '[%d] Error connecting to the API (%s)',
            $statusCode,
            $request->getUri()
          ),
          $statusCode,
          $response->getHeaders(),
          $response->getBody()
        );
      }

      $responseBody = $response->getBody();
      if ($returnType === '\SplFileObject') {
        $content = $responseBody; //stream goes to serializer
      }
      else {
        $content = $responseBody->getContents();
        if ($returnType !== 'string') {
          $content = json_decode($content);
        }
      }

      return [
        ObjectSerializer::deserialize($content, $returnType, []),
        $response->getStatusCode(),
        $response->getHeaders(),
      ];

    } catch (ApiException $e) {
      switch ($e->getCode()) {
        case 200:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Location',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 400:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 401:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 403:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 404:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
      }
      throw $e;
    }
  }

  /**
   * Operation locationByIdAsync
   *
   * Return a Location.
   *
   * @param int $id The location id (required)
   *
   * @return \GuzzleHttp\Promise\PromiseInterface
   * @throws \InvalidArgumentException
   */
  public function locationByIdAsync($id) {
    return $this->locationByIdAsyncWithHttpInfo($id)
      ->then(
        function ($response) {
          return $response[0];
        }
      );
  }

  /**
   * Operation locationByIdAsyncWithHttpInfo
   *
   * Return a Location.
   *
   * @param int $id The location id (required)
   *
   * @return \GuzzleHttp\Promise\PromiseInterface
   * @throws \InvalidArgumentException
   */
  public function locationByIdAsyncWithHttpInfo($id) {
    $returnType = '\Swagger\Client\Model\Location';
    $request = $this->locationByIdRequest($id);

    return $this->client
      ->sendAsync($request, $this->createHttpClientOption())
      ->then(
        function ($response) use ($returnType) {
          $responseBody = $response->getBody();
          if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
          }
          else {
            $content = $responseBody->getContents();
            if ($returnType !== 'string') {
              $content = json_decode($content);
            }
          }

          return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders(),
          ];
        },
        function ($exception) {
          $response = $exception->getResponse();
          $statusCode = $response->getStatusCode();
          throw new ApiException(
            sprintf(
              '[%d] Error connecting to the API (%s)',
              $statusCode,
              $exception->getRequest()->getUri()
            ),
            $statusCode,
            $response->getHeaders(),
            $response->getBody()
          );
        }
      );
  }

  /**
   * Create request for operation 'locationById'
   *
   * @param int $id The location id (required)
   *
   * @return \GuzzleHttp\Psr7\Request
   * @throws \InvalidArgumentException
   */
  protected function locationByIdRequest($id) {
    // verify the required parameter 'id' is set
    if ($id === NULL || (is_array($id) && count($id) === 0)) {
      throw new \InvalidArgumentException(
        'Missing the required parameter $id when calling locationById'
      );
    }

    $resourcePath = '/v1/locations/{id}';
    $formParams = [];
    $queryParams = [];
    $headerParams = [];
    $httpBody = '';
    $multipart = FALSE;


    // path params
    if ($id !== NULL) {
      $resourcePath = str_replace(
        '{' . 'id' . '}',
        ObjectSerializer::toPathValue($id),
        $resourcePath
      );
    }

    // body params
    $_tempBody = NULL;

    if ($multipart) {
      $headers = $this->headerSelector->selectHeadersForMultipart(
        ['application/json']
      );
    }
    else {
      $headers = $this->headerSelector->selectHeaders(
        ['application/json'],
        []
      );
    }

    // for model (json/xml)
    if (isset($_tempBody)) {
      // $_tempBody is the method argument, if present
      $httpBody = $_tempBody;

      if ($headers['Content-Type'] === 'application/json') {
        // \stdClass has no __toString(), so we should encode it manually
        if ($httpBody instanceof \stdClass) {
          $httpBody = \GuzzleHttp\json_encode($httpBody);
        }
        // array has no __toString(), so we should encode it manually
        if (is_array($httpBody)) {
          $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
        }
      }
    }
    elseif (count($formParams) > 0) {
      if ($multipart) {
        $multipartContents = [];
        foreach ($formParams as $formParamName => $formParamValue) {
          $multipartContents[] = [
            'name'     => $formParamName,
            'contents' => $formParamValue,
          ];
        }
        // for HTTP post (form)
        $httpBody = new MultipartStream($multipartContents);

      }
      elseif ($headers['Content-Type'] === 'application/json') {
        $httpBody = \GuzzleHttp\json_encode($formParams);

      }
      else {
        // for HTTP post (form)
        $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
      }
    }


    $defaultHeaders = [];
    if ($this->config->getUserAgent()) {
      $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
    }

    $headers = array_merge(
      $defaultHeaders,
      $headerParams,
      $headers
    );

    $query = \GuzzleHttp\Psr7\build_query($queryParams);
    return new Request(
      'GET',
      $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
      $headers,
      $httpBody
    );
  }

  /**
   * Operation locationByUuid
   *
   * Find location by uuid
   *
   * @param string $uuid The location UUID (required)
   *
   * @return \Swagger\Client\Model\Location
   * @throws \InvalidArgumentException
   * @throws \Swagger\Client\ApiException on non-2xx response
   */
  public function locationByUuid($uuid) {
    [$response] = $this->locationByUuidWithHttpInfo($uuid);
    return $response;
  }

  /**
   * Operation locationByUuidWithHttpInfo
   *
   * Find location by uuid
   *
   * @param string $uuid The location UUID (required)
   *
   * @return array of \Swagger\Client\Model\Location, HTTP status code, HTTP
   *   response headers (array of strings)
   * @throws \InvalidArgumentException
   * @throws \Swagger\Client\ApiException on non-2xx response
   */
  public function locationByUuidWithHttpInfo($uuid) {
    $returnType = '\Swagger\Client\Model\Location';
    $request = $this->locationByUuidRequest($uuid);

    try {
      $options = $this->createHttpClientOption();
      try {
        $response = $this->client->send($request, $options);
      } catch (RequestException $e) {
        throw new ApiException(
          "[{$e->getCode()}] {$e->getMessage()}",
          $e->getCode(),
          $e->getResponse() ? $e->getResponse()->getHeaders() : NULL,
          $e->getResponse() ? $e->getResponse()->getBody()->getContents() : NULL
        );
      }

      $statusCode = $response->getStatusCode();

      if ($statusCode < 200 || $statusCode > 299) {
        throw new ApiException(
          sprintf(
            '[%d] Error connecting to the API (%s)',
            $statusCode,
            $request->getUri()
          ),
          $statusCode,
          $response->getHeaders(),
          $response->getBody()
        );
      }

      $responseBody = $response->getBody();
      if ($returnType === '\SplFileObject') {
        $content = $responseBody; //stream goes to serializer
      }
      else {
        $content = $responseBody->getContents();
        if ($returnType !== 'string') {
          $content = json_decode($content);
        }
      }

      return [
        ObjectSerializer::deserialize($content, $returnType, []),
        $response->getStatusCode(),
        $response->getHeaders(),
      ];

    } catch (ApiException $e) {
      switch ($e->getCode()) {
        case 200:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Location',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 400:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 401:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 403:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 404:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
      }
      throw $e;
    }
  }

  /**
   * Operation locationByUuidAsync
   *
   * Find location by uuid
   *
   * @param string $uuid The location UUID (required)
   *
   * @return \GuzzleHttp\Promise\PromiseInterface
   * @throws \InvalidArgumentException
   */
  public function locationByUuidAsync($uuid) {
    return $this->locationByUuidAsyncWithHttpInfo($uuid)
      ->then(
        function ($response) {
          return $response[0];
        }
      );
  }

  /**
   * Operation locationByUuidAsyncWithHttpInfo
   *
   * Find location by uuid
   *
   * @param string $uuid The location UUID (required)
   *
   * @return \GuzzleHttp\Promise\PromiseInterface
   * @throws \InvalidArgumentException
   */
  public function locationByUuidAsyncWithHttpInfo($uuid) {
    $returnType = '\Swagger\Client\Model\Location';
    $request = $this->locationByUuidRequest($uuid);

    return $this->client
      ->sendAsync($request, $this->createHttpClientOption())
      ->then(
        function ($response) use ($returnType) {
          $responseBody = $response->getBody();
          if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
          }
          else {
            $content = $responseBody->getContents();
            if ($returnType !== 'string') {
              $content = json_decode($content);
            }
          }

          return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders(),
          ];
        },
        function ($exception) {
          $response = $exception->getResponse();
          $statusCode = $response->getStatusCode();
          throw new ApiException(
            sprintf(
              '[%d] Error connecting to the API (%s)',
              $statusCode,
              $exception->getRequest()->getUri()
            ),
            $statusCode,
            $response->getHeaders(),
            $response->getBody()
          );
        }
      );
  }

  /**
   * Create request for operation 'locationByUuid'
   *
   * @param string $uuid The location UUID (required)
   *
   * @return \GuzzleHttp\Psr7\Request
   * @throws \InvalidArgumentException
   */
  protected function locationByUuidRequest($uuid) {
    // verify the required parameter 'uuid' is set
    if ($uuid === NULL || (is_array($uuid) && count($uuid) === 0)) {
      throw new \InvalidArgumentException(
        'Missing the required parameter $uuid when calling locationByUuid'
      );
    }

    $resourcePath = '/v1/locations/with_uuid/{uuid}';
    $formParams = [];
    $queryParams = [];
    $headerParams = [];
    $httpBody = '';
    $multipart = FALSE;


    // path params
    if ($uuid !== NULL) {
      $resourcePath = str_replace(
        '{' . 'uuid' . '}',
        ObjectSerializer::toPathValue($uuid),
        $resourcePath
      );
    }

    // body params
    $_tempBody = NULL;

    if ($multipart) {
      $headers = $this->headerSelector->selectHeadersForMultipart(
        ['application/json']
      );
    }
    else {
      $headers = $this->headerSelector->selectHeaders(
        ['application/json'],
        []
      );
    }

    // for model (json/xml)
    if (isset($_tempBody)) {
      // $_tempBody is the method argument, if present
      $httpBody = $_tempBody;

      if ($headers['Content-Type'] === 'application/json') {
        // \stdClass has no __toString(), so we should encode it manually
        if ($httpBody instanceof \stdClass) {
          $httpBody = \GuzzleHttp\json_encode($httpBody);
        }
        // array has no __toString(), so we should encode it manually
        if (is_array($httpBody)) {
          $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
        }
      }
    }
    elseif (count($formParams) > 0) {
      if ($multipart) {
        $multipartContents = [];
        foreach ($formParams as $formParamName => $formParamValue) {
          $multipartContents[] = [
            'name'     => $formParamName,
            'contents' => $formParamValue,
          ];
        }
        // for HTTP post (form)
        $httpBody = new MultipartStream($multipartContents);

      }
      elseif ($headers['Content-Type'] === 'application/json') {
        $httpBody = \GuzzleHttp\json_encode($formParams);

      }
      else {
        // for HTTP post (form)
        $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
      }
    }


    $defaultHeaders = [];
    if ($this->config->getUserAgent()) {
      $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
    }

    $headers = array_merge(
      $defaultHeaders,
      $headerParams,
      $headers
    );

    $query = \GuzzleHttp\Psr7\build_query($queryParams);
    return new Request(
      'GET',
      $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
      $headers,
      $httpBody
    );
  }

  /**
   * Operation locations
   *
   * Returns all Locations.
   *
   * @param string $type The type of location (optional)
   * @param int $number Number of the location (optional)
   * @param int $animal_id The id of the animal that should belong to the
   *   location (optional)
   *
   * @return \Swagger\Client\Model\Location
   * @throws \InvalidArgumentException
   * @throws \Swagger\Client\ApiException on non-2xx response
   */
  public function locations($type = NULL, $number = NULL, $animal_id = NULL) {
    [$response] = $this->locationsWithHttpInfo($type, $number, $animal_id);
    return $response;
  }

  /**
   * Operation locationsWithHttpInfo
   *
   * Returns all Locations.
   *
   * @param string $type The type of location (optional)
   * @param int $number Number of the location (optional)
   * @param int $animal_id The id of the animal that should belong to the
   *   location (optional)
   *
   * @return array of \Swagger\Client\Model\Location, HTTP status code, HTTP
   *   response headers (array of strings)
   * @throws \InvalidArgumentException
   * @throws \Swagger\Client\ApiException on non-2xx response
   */
  public function locationsWithHttpInfo($type = NULL, $number = NULL, $animal_id = NULL) {
    $returnType = '\Swagger\Client\Model\Location';
    $request = $this->locationsRequest($type, $number, $animal_id);

    try {
      $options = $this->createHttpClientOption();
      try {
        $response = $this->client->send($request, $options);
      } catch (RequestException $e) {
        throw new ApiException(
          "[{$e->getCode()}] {$e->getMessage()}",
          $e->getCode(),
          $e->getResponse() ? $e->getResponse()->getHeaders() : NULL,
          $e->getResponse() ? $e->getResponse()->getBody()->getContents() : NULL
        );
      }

      $statusCode = $response->getStatusCode();

      if ($statusCode < 200 || $statusCode > 299) {
        throw new ApiException(
          sprintf(
            '[%d] Error connecting to the API (%s)',
            $statusCode,
            $request->getUri()
          ),
          $statusCode,
          $response->getHeaders(),
          $response->getBody()
        );
      }

      $responseBody = $response->getBody();
      if ($returnType === '\SplFileObject') {
        $content = $responseBody; //stream goes to serializer
      }
      else {
        $content = $responseBody->getContents();
        if ($returnType !== 'string') {
          $content = json_decode($content);
        }
      }

      $locations = [];
      foreach ($content->locations as $location) {
        $locations[] = ObjectSerializer::deserialize($location, $returnType, []);
      }

      return [
        $locations,
        $response->getStatusCode(),
        $response->getHeaders(),
      ];

    } catch (ApiException $e) {
      switch ($e->getCode()) {
        case 200:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Location',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 401:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 403:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
        case 404:
          $data = ObjectSerializer::deserialize(
            $e->getResponseBody(),
            '\Swagger\Client\Model\Error',
            $e->getResponseHeaders()
          );
          $e->setResponseObject($data);
          break;
      }
      throw $e;
    }
  }

  /**
   * Operation locationsAsync
   *
   * Returns all Locations.
   *
   * @param string $type The type of location (optional)
   * @param int $number Number of the location (optional)
   * @param int $animal_id The id of the animal that should belong to the
   *   location (optional)
   *
   * @return \GuzzleHttp\Promise\PromiseInterface
   * @throws \InvalidArgumentException
   */
  public function locationsAsync($type = NULL, $number = NULL, $animal_id = NULL) {
    return $this->locationsAsyncWithHttpInfo($type, $number, $animal_id)
      ->then(
        function ($response) {
          return $response[0];
        }
      );
  }

  /**
   * Operation locationsAsyncWithHttpInfo
   *
   * Returns all Locations.
   *
   * @param string $type The type of location (optional)
   * @param int $number Number of the location (optional)
   * @param int $animal_id The id of the animal that should belong to the
   *   location (optional)
   *
   * @return \GuzzleHttp\Promise\PromiseInterface
   * @throws \InvalidArgumentException
   */
  public function locationsAsyncWithHttpInfo($type = NULL, $number = NULL, $animal_id = NULL) {
    $returnType = '\Swagger\Client\Model\Location';
    $request = $this->locationsRequest($type, $number, $animal_id);

    return $this->client
      ->sendAsync($request, $this->createHttpClientOption())
      ->then(
        function ($response) use ($returnType) {
          $responseBody = $response->getBody();
          if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
          }
          else {
            $content = $responseBody->getContents();
            if ($returnType !== 'string') {
              $content = json_decode($content);
            }
          }

          $locations = [];
          foreach ($content->locations as $location) {
            $locations[] = ObjectSerializer::deserialize($location, $returnType, []);
          }

          return [
            $locations,
            $response->getStatusCode(),
            $response->getHeaders(),
          ];
        },
        function ($exception) {
          $response = $exception->getResponse();
          $statusCode = $response->getStatusCode();
          throw new ApiException(
            sprintf(
              '[%d] Error connecting to the API (%s)',
              $statusCode,
              $exception->getRequest()->getUri()
            ),
            $statusCode,
            $response->getHeaders(),
            $response->getBody()
          );
        }
      );
  }

  /**
   * Create request for operation 'locations'
   *
   * @param string $type The type of location (optional)
   * @param int $number Number of the location (optional)
   * @param int $animal_id The id of the animal that should belong to the
   *   location (optional)
   *
   * @return \GuzzleHttp\Psr7\Request
   * @throws \InvalidArgumentException
   */
  protected function locationsRequest($type = NULL, $number = NULL, $animal_id = NULL) {

    $resourcePath = '/v1/locations';
    $formParams = [];
    $queryParams = [];
    $headerParams = [];
    $httpBody = '';
    $multipart = FALSE;

    // query params
    if ($type !== NULL) {
      $queryParams['type'] = ObjectSerializer::toQueryValue($type);
    }
    // query params
    if ($number !== NULL) {
      $queryParams['number'] = ObjectSerializer::toQueryValue($number);
    }
    // query params
    if ($animal_id !== NULL) {
      $queryParams['animal_id'] = ObjectSerializer::toQueryValue($animal_id);
    }


    // body params
    $_tempBody = NULL;

    if ($multipart) {
      $headers = $this->headerSelector->selectHeadersForMultipart(
        ['application/json']
      );
    }
    else {
      $headers = $this->headerSelector->selectHeaders(
        ['application/json'],
        []
      );
    }

    // for model (json/xml)
    if (isset($_tempBody)) {
      // $_tempBody is the method argument, if present
      $httpBody = $_tempBody;

      if ($headers['Content-Type'] === 'application/json') {
        // \stdClass has no __toString(), so we should encode it manually
        if ($httpBody instanceof \stdClass) {
          $httpBody = \GuzzleHttp\json_encode($httpBody);
        }
        // array has no __toString(), so we should encode it manually
        if (is_array($httpBody)) {
          $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
        }
      }
    }
    elseif (count($formParams) > 0) {
      if ($multipart) {
        $multipartContents = [];
        foreach ($formParams as $formParamName => $formParamValue) {
          $multipartContents[] = [
            'name'     => $formParamName,
            'contents' => $formParamValue,
          ];
        }
        // for HTTP post (form)
        $httpBody = new MultipartStream($multipartContents);

      }
      elseif ($headers['Content-Type'] === 'application/json') {
        $httpBody = \GuzzleHttp\json_encode($formParams);

      }
      else {
        // for HTTP post (form)
        $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
      }
    }


    $defaultHeaders = [];
    if ($this->config->getUserAgent()) {
      $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
    }

    $headers = array_merge(
      $defaultHeaders,
      $headerParams,
      $headers
    );

    $query = \GuzzleHttp\Psr7\build_query($queryParams);
    return new Request(
      'GET',
      $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
      $headers,
      $httpBody
    );
  }

  /**
   * Create http client option
   *
   * @return array of http client options
   * @throws \RuntimeException on file opening failure
   */
  protected function createHttpClientOption() {
    $options = [];
    if ($this->config->getDebug()) {
      $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
      if (!$options[RequestOptions::DEBUG]) {
        throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
      }
    }

    return $options;
  }
}
